#!/usr/bin/env node

/* eslint-env node */

const path = require('path');
const Runner = require('../index');
const colorSupport = require('color-support') || {};
const makeOptions = require('optionator');
const glob = require('glob');
const ignore = require('ignore');
const c = require('ansi-colors');
c.enabled = colorSupport.hasBasic;

const optionSpec = {
  options: [
    { option: 'help', alias: 'h',    type: 'Boolean',  description: 'displays help' },
    { option: 'port', alias: 'p',    type: 'Int',      description: 'port', default: '8080' },
    { option: 'config', alias: 'c',  type: 'String',   description: 'config file' },
    { option: 'timeout',             type: 'Int',      description: 'the default timeout', default: '5000' },
    { option: 'verbose', alias: 'v', type: 'Boolean',  description: 'print console.log from browser' },
    { option: 'follow-links',        type: 'String',   description: 'follow links', enum: ['local', 'remote', 'both', 'none'], default: 'none' },
    { option: 'ignore-pattern',      type: '[String]', description: 'glob to ignore', concatRepeatedArrays: true },
    { option: 'dry-run',             type: 'Boolean',  description: 'show the list of files to check and exit'},
  ],
  prepend: `Usage: check-all-the-errors [options] path-to-serve [...glob]

NOTE: all globs and ignore-patterns are relative to path-to-serve
which means you generally need to quote them so the shell does not
expand them in place.

examples:

  check-all-the-errors somedir              # eqv: somedir/*.html
  check-all-the-errors somedir "*.html"     # eqv: somedir/*.html
  check-all-the-errors somedir "**/*.html"  # eqv: somedir/**/*.html
  check-all-the-errors somedir "foo/*.html" # eqv: somedir/foo/*.html
  `,
  helpStyle: {
    typeSeparator: '=',
    descriptionSeparator: ' : ',
    initialIndent: 4,
  },
};
const optionator = makeOptions(optionSpec);

let args;
try {
  args = optionator.parse(process.argv);
} catch (e) {
  console.error(e);
  printHelp();
}

function printHelp() {
  console.log(optionator.generateHelp());
  process.exit(1);  // eslint-disable-line no-process-exit
}

if (args.help || args._.length < 1) {
  printHelp();
}

const baseDir = args._.shift();
const scanDirs = args._.length ? args._ : ['*.html'];

const igFilter = ignore().add(args.ignorePattern || []).createFilter();
const filenames = new Set();
const globOptions = {nodir: true};
for (const scanDir of scanDirs) {
  glob.sync(path.join(baseDir, scanDir), globOptions)
      .map(v => path.relative(baseDir, v))
      .filter(v => igFilter(v))
      .forEach(v => filenames.add(v));
}

if (args.dryRun) {
  console.log(Array.from(filenames).join('\n'));
  process.exit(0);  // eslint-disable-line no-process-exit
}

const logColor = (color, ...args) => {
  console.log(c[color]([...args].join(' ')));
};

const log = (...args) => {
  logColor('gray', ...args);
};
const error = (...args) => {
  logColor('red', ...args);
};

const options = Object.assign({}, args, {
  dir: baseDir,
  hrefs: Array.from(filenames).map(v => `http://localhost:${args.port}/${v}`),
});
let numErrors = 0;
const r = new Runner(options);
r.on('load', (e) => log('load:', e.href));
// r.on('idle', (e) => log('done:', e.url));
r.on('error', (e) => {
  ++numErrors;
  switch (e.type) {
    case 'msg':
      error('error msg:', e.href, e.type, e.text, e.msg);
      break;
    case 'exception':
      error('exception:', e.href, e.type, e.error);
      break;
    case 'error':
      error('error:', e.href, e.type, e.error);
      break;
    case 'pageerror':
      error('pageerror:', e.href, e.type, e.error);
      break;
    case 'badlink':
      error('missing link:', e.href, `[${e.status}] linked from\n  ${e.links.join('\n  ')}`);
      break;
    default:
      throw new Error('unhandled error type');
  }
});
r.on('finish', () => {
  log('---done---');
  process.exit(numErrors ? 1 : 0);  // eslint-disable-line no-process-exit
});

