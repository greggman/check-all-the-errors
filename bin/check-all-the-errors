#!/usr/bin/env node

/* eslint-env node */

const fs = require('fs');
const path = require('path');
const Runner = require('../runner');
const debug = require('debug')('check-all-the-tnings');
const colorSupport = require('color-support') || {};
const makeOptions = require('optionator');
const glob = require('glob');
const ignore = require('ignore');
const isURL = require('./is-url');

const c = require('ansi-colors');
c.enabled = colorSupport.hasBasic;

const optionSpec = {
  options: [
    { option: 'help', alias: 'h',    type: 'Boolean',  description: 'displays help' },
    { option: 'port', alias: 'p',    type: 'Int',      description: 'port', default: '8080' },
    { option: 'timeout',             type: 'Int',      description: 'the default timeout', default: '5000' },
    { option: 'follow-links',        type: 'String',   description: 'follow links', enum: ['local', 'remote', 'both', 'none'], default: 'none' },
    { option: 'ignore-pattern',      type: '[String]', description: 'glob to ignore', concatRepeatedArrays: true },
    { option: 'dry-run',             type: 'Boolean',  description: 'show the list of files to check and exit'},
    { option: 'output', alias: 'o',  type: 'String',   description: 'output results to file in json'},
    { option: 'verbose', alias: 'v', type: 'Boolean',  description: 'print console.log from browser' },
  ],
  prepend: `Usage: check-all-the-errors [options] path-to-serve-or-url [...globs-or-urls]

NOTE: all globs and ignore-patterns are relative to path-to-serve
which means you generally need to quote them so the shell does not
expand them in place.

examples:

  check-all-the-errors someDir              # eqv: someDir/*.html
  check-all-the-errors someDir "*.html"     # eqv: someDir/*.html
  check-all-the-errors someDir "**/*.html"  # eqv: someDir/**/*.html
  check-all-the-errors someDir "foo/*.html" # eqv: someDir/foo/*.html
  `,
  helpStyle: {
    typeSeparator: '=',
    descriptionSeparator: ' : ',
    initialIndent: 4,
  },
};
const optionator = makeOptions(optionSpec);

let args;
try {
  args = optionator.parse(process.argv);
} catch (e) {
  console.error(e);
  printHelp();
}

function printHelp() {
  console.log(optionator.generateHelp());
  process.exit(1);  // eslint-disable-line no-process-exit
}

if (args.help || args._.length < 1) {
  printHelp();
}

const logColor = (color, ...args) => {
  console.log(c[color]([...args].join(' ')));
};

const log = (...args) => {
  logColor('gray', ...args);
};
const error = (...args) => {
  logColor('red', ...args);
};

async function main(args) {
  const baseDir = args._.shift();
  const isRemote = isURL(baseDir);
  const result = await (isRemote ? runRemote(baseDir, args) : runLocal(baseDir, args));
  let exitCode = result.numErrors ? 1 : 0;
  if (!args.dryRun) {
    if (args.output) {
      exitCode = 0;  // if you wanted the result then you probably don't want to stop processing?
      log('writing:', args.output);
      fs.writeFileSync(args.output, JSON.stringify(result, null, 2));
    }
  }
  process.exit(exitCode);  // eslint-disable-line no-process-exit
}
main(args);

async function runRemote(baseDir, args) {
  const hrefs = [baseDir, ...args._];
  if (args.dryRun) {
    console.log(hrefs.join('\n'));
    return 0;
  }

  return await run(hrefs, args);
}

function runLocal(baseDir, args) {
  return new Promise(resolve => {
    const scanDirs = args._.length ? args._ : ['*.html'];
    const igFilter = ignore().add(args.ignorePattern || []).createFilter();
    const globOptions = {nodir: true};
    const filenames = new Set();
    for (const scanDir of scanDirs) {
      glob.sync(path.join(baseDir, scanDir), globOptions)
          .map(v => path.relative(baseDir, v))
          .filter(v => igFilter(v))
          .forEach(v => filenames.add(v));
    }

    if (args.dryRun) {
      console.log(Array.from(filenames).join('\n'));
      resolve({numErrors: 0});
    }

    const Servez = require('servez-lib');
    const server = new Servez(Object.assign({
      root: baseDir,
      port: args.port,
      scan: true,
    }));
    server.on('start', ({baseUrl}) => {
      process.nextTick(async() => {
        const result = await run(Array.from(filenames).map(v => `${baseUrl}/${v}`), args);
        server.close();
        resolve(result);
      });
    });
  });
}

function run(hrefs) {
  return new Promise((resolve) => {
    const resultInfoMap = new Map();

    function getResultInfo(href) {
      let info = resultInfoMap.get(href);
      if (!info) {
        info = {
          status: -1,  // not visited
          errors: [],
        };
        resultInfoMap.set(href, info);
      }
      return info;
    }

    const options = Object.assign({}, args, {
      hrefs,
    });
    const responses = [];
    let numErrors = 0;
    const r = new Runner(options);
    // page that we're about to try to load
    r.on('load', (e) => {
      debug('load:', e.href);
      getResultInfo(e.href);
      log('load:', e.href);
    });
    // status of page that was loaded
    r.on('status', (e) => {
      debug('status:', e.href, e.status);
      getResultInfo(e.href).status = e.status;
    });
    // status of network requests (html, jpg, png, css, etc)
    r.on('response', (e) => {
      debug('response:', e.href, e.status);
      // note: if a page fails to finish we may have downloaded the page
      // but some error prevented it from running/timedout etc...
      const info = resultInfoMap.get(e.href);
      if (info) {
        info.status = e.status;
      }
      responses.push(e);
    });
    // errors of all types
    r.on('error', (e) => {
      ++numErrors;
      const info = getResultInfo(e.href);
      const err = Object.assign({}, e);
      delete err.href;
      info.errors.push(err);
      switch (e.type) {
        case 'msg':
          error('error msg:', e.href, e.type, e.text, e.msg);
          break;
        case 'exception':
          error('exception:', e.href, e.type, e.error);
          break;
        case 'error':
          error('error:', e.href, e.type, e.error);
          break;
        case 'pageerror':
          error('pageerror:', e.href, e.type, e.error);
          break;
        case 'badlink':
          error('missing link:', e.link, `[${e.status}] referenced by ${e.href}`);
          break;
        default:
          throw new Error('unhandled error type');
      }
    });
    r.on('finish', () => {
      log('---done---');
      resolve({
        numErrors,
        pages: Object.fromEntries(resultInfoMap.entries()),
        responses,
      });
    });
  });
}