#!/usr/bin/env node

/* eslint-env node */

const path = require('path');
const Runner = require('../runner');
const colorSupport = require('color-support') || {};
const makeOptions = require('optionator');
const glob = require('glob');
const ignore = require('ignore');
const isURL = require('./is-url');

const c = require('ansi-colors');
c.enabled = colorSupport.hasBasic;

const optionSpec = {
  options: [
    { option: 'help', alias: 'h',    type: 'Boolean',  description: 'displays help' },
    { option: 'port', alias: 'p',    type: 'Int',      description: 'port', default: '8080' },
    { option: 'timeout',             type: 'Int',      description: 'the default timeout', default: '5000' },
    { option: 'verbose', alias: 'v', type: 'Boolean',  description: 'print console.log from browser' },
    { option: 'follow-links',        type: 'String',   description: 'follow links', enum: ['local', 'remote', 'both', 'none'], default: 'none' },
    { option: 'ignore-pattern',      type: '[String]', description: 'glob to ignore', concatRepeatedArrays: true },
    { option: 'dry-run',             type: 'Boolean',  description: 'show the list of files to check and exit'},
  ],
  prepend: `Usage: check-all-the-errors [options] path-to-serve [...glob]

NOTE: all globs and ignore-patterns are relative to path-to-serve
which means you generally need to quote them so the shell does not
expand them in place.

examples:

  check-all-the-errors somedir              # eqv: somedir/*.html
  check-all-the-errors somedir "*.html"     # eqv: somedir/*.html
  check-all-the-errors somedir "**/*.html"  # eqv: somedir/**/*.html
  check-all-the-errors somedir "foo/*.html" # eqv: somedir/foo/*.html
  `,
  helpStyle: {
    typeSeparator: '=',
    descriptionSeparator: ' : ',
    initialIndent: 4,
  },
};
const optionator = makeOptions(optionSpec);

let args;
try {
  args = optionator.parse(process.argv);
} catch (e) {
  console.error(e);
  printHelp();
}

function printHelp() {
  console.log(optionator.generateHelp());
  process.exit(1);  // eslint-disable-line no-process-exit
}

if (args.help || args._.length < 1) {
  printHelp();
}

const logColor = (color, ...args) => {
  console.log(c[color]([...args].join(' ')));
};

const log = (...args) => {
  logColor('gray', ...args);
};
const error = (...args) => {
  logColor('red', ...args);
};

async function main(args) {
  const baseDir = args._.shift();
  const isRemote = isURL(baseDir);
  const numErrors = await (isRemote ? runRemote(baseDir, args) : runLocal(baseDir, args));
  process.exit(numErrors ? 1 : 0);  // eslint-disable-line no-process-exit
}
main(args);

async function runRemote(baseDir, args) {
  const hrefs = [baseDir, ...args._];
  if (args.dryRun) {
    console.log(hrefs.join('\n'));
    return 0;
  }

  return await run(hrefs);
}

function runLocal(baseDir, args) {
  return new Promise(resolve => {
    const scanDirs = args._.length ? args._ : ['*.html'];
    const igFilter = ignore().add(args.ignorePattern || []).createFilter();
    const globOptions = {nodir: true};
    const filenames = new Set();
    for (const scanDir of scanDirs) {
      glob.sync(path.join(baseDir, scanDir), globOptions)
          .map(v => path.relative(baseDir, v))
          .filter(v => igFilter(v))
          .forEach(v => filenames.add(v));
    }

    if (args.dryRun) {
      console.log(Array.from(filenames).join('\n'));
      return 0;
    }

    const Servez = require('servez-lib');
    const server = new Servez(Object.assign({
      root: baseDir,
      port: args.port,
      scan: true,
    }));
    server.on('start', ({baseUrl}) => {
      process.nextTick(async() => {
        const numErrors = await run(Array.from(filenames).map(v => `${baseUrl}/${v}`));
        server.close();
        resolve(numErrors);
      });
    });
  });
}

function run(hrefs) {
  return new Promise((resolve) => {
    const options = Object.assign({}, args, {
      hrefs,
    });
    let numErrors = 0;
    const r = new Runner(options);
    r.on('load', (e) => log('load:', e.href));
    // r.on('idle', (e) => log('done:', e.url));
    r.on('error', (e) => {
      ++numErrors;
      switch (e.type) {
        case 'msg':
          error('error msg:', e.href, e.type, e.text, e.msg);
          break;
        case 'exception':
          error('exception:', e.href, e.type, e.error);
          break;
        case 'error':
          error('error:', e.href, e.type, e.error);
          break;
        case 'pageerror':
          error('pageerror:', e.href, e.type, e.error);
          break;
        case 'badlink':
          error('missing link:', e.href, `[${e.status}] linked from\n  ${e.links.join('\n  ')}`);
          break;
        default:
          throw new Error('unhandled error type');
      }
    });
    r.on('finish', () => {
      log('---done---');
      resolve(numErrors);
    });
  });
}